# parser.py
import ply.yacc as yacc
from lexer import tokens
from tables import symbol_table, error_table
from icg import TriploTable   # <--- OK

# ===== Triplos =====
trip = TriploTable()          # <--- OK
for_stack = []                # <--- Stack para etiquetas de for (inicio_loop, fin_loop)

precedence = (
    ('left', 'MAYOR', 'MENOR', 'MAYORIGUAL', 'MENORIGUAL', 'IGUAL', 'DIF'),  # Comparaciones (menor precedencia)
    ('left', 'MAS', 'MENOS'),
    ('left', 'MULT', 'DIV', 'MOD'),
)

def tipos_compatibles_igual(t1, t2):
    if t1 is None or t2 is None:
        return False
    return t1 == t2

def es_cadena(t):
    return t == 'meow'

def es_num(t):
    return t in ('cat', 'cats')

def p_programa(p):
    '''programa : lista_sentencias_opt'''
    # Añadir un triplo final para marcar el fin
    trip.add('HALT', res='...')
    pass

def p_lista_sentencias_opt(p):
    '''lista_sentencias_opt : lista_sentencias
                            | empty'''
    pass

def p_lista_sentencias(p):
    '''lista_sentencias : lista_sentencias sentencia
                        | sentencia'''
    pass

def p_sentencia(p):
    '''sentencia : declaracion
                 | asignacion
                 | ciclo_for
                 | expresion PUNTOYCOMA'''
    pass

# -------- Declaraciones --------
def p_declaracion(p):
    '''declaracion : TIPO ID PUNTOYCOMA'''
    tipo = p[1]
    lex  = p[2]
    if symbol_table.exists(lex):
        error_table.add(None, lex, p.lineno(2), "Declaración duplicada")
        trip.error(lex, "Declaración duplicada")  # también en triplos (ERROR con DO/DF vacíos)
    else:
        symbol_table.add(lex, tipo)

# -------- Expresiones base --------
def p_expresion_group(p):
    '''expresion : LPAREN expresion RPAREN'''
    p[0] = p[2]

def p_expresion_id(p):
    '''expresion : ID'''
    nombre = p[1]
    ln     = p.lineno(1)
    if not symbol_table.exists(nombre):
        error_table.add(None, nombre, ln, "Variable indefinida")
        trip.error(nombre, "Variable indefinida")
        p[0] = {'lexema': nombre, 'tipo': None, 'lineno': ln, 'place': nombre}
    else:
        p[0] = {'lexema': nombre, 'tipo': symbol_table.get(nombre), 'lineno': ln, 'place': nombre}

def p_expresion_badid(p):
    '''expresion : BADID'''
    ln = p.lineno(1)
    error_table.add(None, p[1], ln, "Variable indefinida")
    trip.error(p[1], "Variable indefinida")
    p[0] = {'lexema': p[1], 'tipo': None, 'lineno': ln, 'place': p[1]}

def p_expresion_entero(p):
    '''expresion : ENTERO'''
    val = str(p[1])
    p[0] = {'lexema': val, 'tipo': 'cat', 'lineno': p.lineno(1), 'place': val}

def p_expresion_real(p):
    '''expresion : REAL'''
    val = str(p[1])
    p[0] = {'lexema': val, 'tipo': 'cats', 'lineno': p.lineno(1), 'place': val}

def p_expresion_cadena(p):
    '''expresion : CADENA'''
    val = p[1]
    p[0] = {'lexema': val, 'tipo': 'meow', 'lineno': p.lineno(1), 'place': val}

def p_expresion_unaria(p):
    '''expresion : MAS expresion
                 | MENOS expresion'''
    op = p[1]
    e  = p[2]
    
    if op == '-':
        # Lógica de acumulador: t1 = e, t1 = NEG t1
        t = trip.new_temp()
        
        # 1. Cargar valor en temporal
        trip.add(':=', arg1=e['place'], arg2=None, res=t)
        
        # 2. Negar el temporal
        trip.add('NEG', arg1=t, arg2=None, res=t)
        
        # 3. Liberar temporal hijo (si era un temporal)
        trip.free_temp(e['place'])
        
        p[0] = {'lexema': t, 'tipo': e['tipo'], 'lineno': e['lineno'], 'place': t}
    else:
        # op es '+', no hace nada, solo pasa la expresión hija
        p[0] = e

def p_expresion_binaria(p):
    '''expresion : expresion MAS expresion
                 | expresion MENOS expresion
                 | expresion MULT expresion
                 | expresion DIV expresion
                 | expresion MOD expresion'''
    izq, op, der = p[1], p[2], p[3]
    t1, t2       = izq['tipo'], der['tipo']

    if t1 is not None and t2 is not None and t1 != t2:
        error_table.add(None, izq['lexema'], izq['lineno'],
                        f"Incompatibilidad de tipos ({t1} <- {t2})")
        error_table.add(None, der['lexema'], der['lineno'],
                        f"Incompatibilidad de tipos ({t2} <- {t1})")
        trip.error(f"{izq['lexema']} {op} {der['lexema']}", "Incompatibilidad de tipos")

    if t1 == t2:
        tres = t1
    elif t1 is None:
        tres = t2
    elif t2 is None:
        tres = t1
    else:
        tres = None

    # Lógica de acumulador (PDF): t1 = izq, t1 = t1 op der
    op_map = {'+':'ADD', '-':'SUB', '*':'MUL', '/':'DIV', '%':'MOD'}
    
    # 1. Pedimos un temporal NUEVO para la operación
    t = trip.new_temp()
    
    # 2. Cargar 'izq' en el temporal 't' (ej. T1 = $1ITA)
    trip.add(':=', arg1=izq['place'], arg2=None, res=t)
    
    # 3. Operar 'der' contra 't' y guardar en 't' (ej. T1 = T1 + 5)
    trip.add(op_map[op], arg1=t, arg2=der['place'], res=t)
    
    # 4. Liberar temporales hijos (si es que eran temporales)
    trip.free_temp(izq['place'])
    trip.free_temp(der['place'])
    
    # 5. Retornar el nuevo temporal 't'
    p[0] = {'lexema': t, 'tipo': tres, 'lineno': izq['lineno'], 'place': t}

# -------- Expresiones de Comparación (para TR1) --------
def p_expresion_comparacion(p):
    '''expresion : expresion MAYOR expresion
                 | expresion MENOR expresion
                 | expresion MAYORIGUAL expresion
                 | expresion MENORIGUAL expresion
                 | expresion IGUAL expresion
                 | expresion DIF expresion'''
    izq, op, der = p[1], p[2], p[3]

    # Validación de tipos (opcional pero recomendado)
    t1, t2 = izq['tipo'], der['tipo']
    if t1 is not None and t2 is not None and t1 != t2:
        error_table.add(None, izq['lexema'], izq['lineno'],
                        f"Incompatibilidad de tipos en comparación ({t1} vs {t2})")
        error_table.add(None, der['lexema'], der['lineno'],
                        f"Incompatibilidad de tipos en comparación ({t2} vs {t1})")
        trip.error(f"{izq['lexema']} {op} {der['lexema']}", "Incompatibilidad de tipos")

    # Mapa de operadores de comparación a triplos
    op_map = {
        '>': 'GT', '>=': 'GTE', '<': 'LT', '<=': 'LTE', '==': 'EQ', '!=': 'NEQ'
    }

    # 1. Pedimos un temporal NUEVO (este es tu TR1)
    t = trip.new_temp()

    # 2. Generar el triplo de comparación (Ej: LTE, $1ITA, 5, t1)
    #    Aquí no usamos el "acumulador" de 2 pasos, es una sola operación.
    trip.add(op_map[op], arg1=izq['place'], arg2=der['place'], res=t)

    # 3. Liberar temporales hijos (si es que eran temporales)
    trip.free_temp(izq['place'])
    trip.free_temp(der['place'])

    # 4. Retornar el nuevo temporal 't'
    #    Usamos 'boolean' como tipo simbólico
    p[0] = {'lexema': t, 'tipo': 'boolean', 'lineno': izq['lineno'], 'place': t}

# -------- Asignaciones --------
def p_asignacion_id(p):
    '''asignacion : ID ASIGNACION expresion PUNTOYCOMA'''
    nombre = p[1]
    ln     = p.lineno(1)

    if not symbol_table.exists(nombre):
        error_table.add(None, nombre, ln, "Variable indefinida")
        trip.error(nombre, "Variable indefinida")
        # Limpieza de errores colaterales en la misma línea (tu comportamiento original)
        error_table.errors = [
            e for e in error_table.errors
            if not (e.get('Renglón') == ln and e.get('Lexema') != nombre)
        ]
        p[0] = {'lexema': nombre, 'tipo': None, 'lineno': ln, 'place': nombre}
        return

    tipo_izq = symbol_table.get(nombre)
    tipo_der = p[3]['tipo']  # puede ser None

    if tipo_der is not None and tipo_izq != tipo_der:
        msg = f"Incompatibilidad de tipos ({tipo_izq} <- {tipo_der})"
        error_table.add(None, nombre, ln, msg)
        trip.error(nombre, msg)

    # --- LÓGICA DE ASIGNACIÓN MODIFICADA ---
    rhs_place = p[3]['place']

    # Checamos si la expresión era compleja (usa un temporal 'tX')
    # o simple (un literal '7' o una variable '$VAR')
    is_complex_expr = (rhs_place and rhs_place.startswith('t'))

    if is_complex_expr:
        # Caso: $1ITA = t1 (donde t1 = ...+...)
        # La expresión ya generó el código. Solo falta el 'store' final.
        trip.add(':=', arg1=rhs_place, arg2=None, res=nombre)
        
        # Y liberamos el temporal
        trip.free_temp(rhs_place)
    else:
        # Caso: $1ITA = 7 (PDF: T1=7, $1ITA=T1)
        # Necesitamos el Load/Store de 2 pasos
        t = trip.new_temp()
        
        # 1. Load (ej. T1 = 7)
        trip.add(':=', arg1=rhs_place, arg2=None, res=t)
        
        # 2. Store (ej. $1ITA = T1)
        trip.add(':=', arg1=t, arg2=None, res=nombre)
        
        # 3. Liberar el temporal
        trip.free_temp(t)

    p[0] = {'lexema': nombre, 'tipo': tipo_izq, 'lineno': ln, 'place': nombre}

def p_asignacion_badid(p):
    '''asignacion : BADID ASIGNACION expresion PUNTOYCOMA'''
    ln = p.lineno(1)
    lhs = p[1]
    error_table.add(None, lhs, ln, "Variable indefinida")
    trip.error(lhs, "Variable indefinida")
    error_table.errors = [
        e for e in error_table.errors
        if not (e.get('Renglón') == ln and e.get('Lexema') != lhs)
    ]
    trip.add(':=', arg1=p[3].get('place'), arg2=None, res=lhs)
    p[0] = {'lexema': lhs, 'tipo': None, 'lineno': ln, 'place': lhs}

# -------- For (CORREGIDO - usa buffer para orden correcto) --------
def p_ciclo_for(p):
    '''ciclo_for : FOR LPAREN asignacion condicion_opt PUNTOYCOMA incr_for_buffered RPAREN LBRACE lista_sentencias_opt RBRACE'''
    # Cuando llegamos aquí:
    # - p[3] (asignacion init) ya generó sus triplos
    # - p[4] (condicion_opt) ya generó sus triplos (incluyendo el temporal con el resultado)
    # - p[6] (incr_for_buffered) guardó sus triplos EN UN BUFFER (no en la tabla principal)
    # - p[9] (lista_sentencias_opt body) ya generó sus triplos
    
    # Ahora generamos la estructura de control en el orden correcto:
    # 1. LABEL_begin (donde empieza el loop, antes de la condición)
    # 2. IF_FALSE_GOTO (usando la condición)
    # 3. (body ya está aquí)
    # 4. (incremento lo insertamos ahora desde el buffer)
    # 5. GOTO begin
    # 6. LABEL_end
    
    # PASO 1: Insertar LABEL_begin ANTES de donde evaluamos la condición
    # Problema: la condición ya se evaluó. Necesitamos insertar ANTES.
    # Solución: Guardar posición antes de la condición con un marcador
    
    # Por ahora, simplifiquemos: NO vamos a reordenar retroactivamente
    # En su lugar, generaremos todo en el orden que podamos
    
    # Obtener la condición
    cond = p[4]
    
    # Obtener el buffer del incremento
    incr_triplos = p[6]  # Este es la lista de triplos del incremento
    
    # Generar etiquetas
    L_begin = trip.new_label("L_for_begin")
    L_end = trip.new_label("L_for_end")
    
    # LABEL de inicio (debería ir antes de evaluar la condición, pero ya es tarde)
    trip.add('LABEL', arg1=L_begin, res='-')
    
    # IF_FALSE_GOTO usando la condición
    if cond is not None and isinstance(cond, dict) and 'place' in cond:
        trip.add('IF_FALSE_GOTO', arg1=cond['place'], res=L_end)
    
    # El body (p[9]) ya generó sus triplos aquí
    
    # Insertar el incremento desde el buffer
    if incr_triplos:
        trip.insert_triplos(incr_triplos)
    
    # GOTO al inicio
    trip.add('GOTO', arg1=L_begin, res='-')
    
    # LABEL de fin
    trip.add('LABEL', arg1=L_end, res='-')

def p_incr_for_buffered(p):
    '''incr_for_buffered : asignacion'''
    # Esta producción intercepta la asignación del incremento
    # y la guarda en un buffer en lugar de añadirla directamente
    
    # Iniciar buffering
    trip.start_buffering()
    
    # Procesar la asignación (esto la guardará en el buffer)
    # p[1] ya tiene el resultado de la asignación
    
    # Terminar buffering y obtener los triplos
    buffered = trip.end_buffering()
    
    # Retornar los triplos buffer eados para que p_ciclo_for los use
    p[0] = buffered

def p_condicion_opt(p):
    '''condicion_opt : expresion
                     | empty'''
    if len(p) == 2 and p[1] is not None:
        p[0] = p[1]
    else:
        p[0] = None

def p_empty(p):
    'empty :'
    pass

def p_error(p):
    # Puedes agregar registro sintáctico si lo deseas:
    # if p is None: trip.error(None, "Fin de entrada inesperado")
    # else: trip.error(str(getattr(p, 'value', '?')), "Token inesperado")
    pass

parser = yacc.yacc(debug=False)
